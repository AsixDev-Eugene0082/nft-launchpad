const { expect } = require('chai')

const { defaultFixture } = require('../_fixture')
const { getSigForMintV5, loadFixture } = require('../helpers')

const ONE_ETH = ethers.utils.parseEther('1')

// Check that things mechanically work
describe('OriginERC721_v5 mint reentrancy', () => {
  let deployerAddress, exploit, factory, master, minter, nftv5, token

  before(async function () {
    const {
      factoryV5,
      nftv5: nftv5_,
      master: master_
    } = await loadFixture(defaultFixture)
    const { deployerAddr } = await getNamedAccounts()

    deployerAddress = deployerAddr
    factory = factoryV5
    master = master_
    minter = ethers.provider.getSigner(4)
    nftv5 = nftv5_
  })

  beforeEach(async function () {
    const tx = await factory
      .connect(master)
      .createTokenWithMinter(
        'Reenter',
        'REENTER',
        'https://nft.example.com/nft/',
        123,
        await minter.getAddress(),
        [await minter.getAddress()],
        [100]
      )

    const receipt = await tx.wait(1)

    const createTokenEvent = receipt.events.find(
      (e) => e.event === 'CreateToken'
    )

    token = nftv5.attach(createTokenEvent.args.addr)

    expect(await token.maxSupply()).to.equal(123)

    await deployments.deploy('Reentrancy_OriginERC721_v5', {
      from: deployerAddress,
      args: [token.address]
    })

    exploit = await ethers.getContract('Reentrancy_OriginERC721_v5')

    expect(await exploit.callsMade()).to.equal(0)
  })

  it('does not mint more than count', async function () {
    const block = await ethers.provider.getBlock()
    const price = ONE_ETH.div(2)
    const count = 5
    const mintLimit = 5
    const expires = block.timestamp + 5

    const sig = await getSigForMintV5({
      signer: minter,
      token,
      buyer: exploit.address, // Tokens need to be minted to exploit contract
      count,
      price,
      mintLimit,
      expires
    })

    const runs = 3
    await expect(
      exploit.mintSome(
        runs,
        //buyer,
        count,
        price,
        mintLimit,
        expires,
        sig,
        { value: price.mul(runs) }
      )
    ).to.be.revertedWith('Max mint limit')
  })

  it('does not mint entire collection', async function () {
    const block = await ethers.provider.getBlock()
    const price = ONE_ETH.div(2)
    const count = 5
    const mintLimit = 5
    const expires = block.timestamp + 5

    const sig = await getSigForMintV5({
      signer: minter,
      token,
      buyer: exploit.address, // Tokens need to be minted to exploit contract
      count,
      price,
      mintLimit,
      expires
    })

    const maxSupply = await token.maxSupply()

    await expect(
      exploit.mintAll(count, price, mintLimit, expires, sig, {
        value: price.mul(maxSupply)
      })
    ).to.be.revertedWith('Max mint limit')
  })
})
